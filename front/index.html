<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <style>
    body > div {
      float: left;
    }
    body > * {
      margin: 10px;
    }
    #canvas {
      border: black 3px solid;
      margin: auto;
      padding: auto;
    }
    #controllers > * {
      margin: 5px;
    }
    #controllers > input {
      width: 100%;
    }
    #canvas_container {
      position: relative;
      width: 806px;
      height: 806px;
    }
    #rooms input {
      margin-left: 10px;
      float: right;
    }
    #rooms {
      min-width: 200px;
    }
    #rooms tr:nth-child(even) {
      background-color: #dfdfdf;
    }
  </style>
</head>
<body>
  <h1 id="room_header">Canvas</h1>
  <div id="canvas_container">
    <canvas id="canvas" width="800" height="800"></canvas>
  </div>

  <div id="controllers">
    <h4>Rooms</h4>
    <table id="rooms"></table>
    <input type="button" id="clean" value="Clean canvas" />
    <input type="button" id="leave" value="Leave room" />
  </div>

  <script>
    const roomsList = document.getElementById("rooms");
    const clean = document.getElementById("clean");
    const leave = document.getElementById("leave");
    const roomHeader = document.getElementById("room_header");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    let socket;

    let lastPoints = {}
    let currX = null, currY = null, drawing = false;

    const draw = function(ox, oy, nx, ny) {
      ctx.beginPath();
      ctx.moveTo(ox, oy);
      ctx.lineTo(nx, ny);
      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.closePath();
    };

    const cleanCanvas = () => {
      lastPoints = {};
      currX = null;
      currY = null;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    };

    const onSocketMessage = e => {
      mesg = JSON.parse(e.data);

      switch (mesg.type) {
        case 0:
          let i = 0;
          if (lastPoints[mesg.line.ind] === undefined) {
            lastPoints[mesg.line.ind] = [mesg.line.x[0], mesg.line.y[0]];
            i = 1;
          }

          for (;i < mesg.line.x.length; i++) {
            draw(lastPoints[mesg.line.ind][0], lastPoints[mesg.line.ind][1], mesg.line.x[i], mesg.line.y[i])
            lastPoints[mesg.line.ind] = [mesg.line.x[i], mesg.line.y[i]]
          }

          lastPoints[mesg.line.ind] = [mesg.line.x[mesg.line.x.length-1], mesg.line.y[mesg.line.y.length-1]];
          break;
        case 2:
          cleanCanvas();
      }
    };

     const onMouseMove = e => { if (drawing) {
      const __rect = canvas.getBoundingClientRect();

      const __newX = e.clientX - __rect.left + window.pageXOffset;
      const __newY = e.clientY - __rect.top + window.pageYOffset;

      if (currX !== null && currY !== null)
        draw(currX, currY, __newX, __newY);

      currX = __newX;
      currY = __newY;

      socket.send(JSON.stringify({
        type: 0,
        line: { x: [currX], y: [currY] }
      }));
    }};

    const onMouseDown = e => {
      drawing = true;
      const __rect = canvas.getBoundingClientRect();

      currX = e.clientX - __rect.left + window.pageXOffset;
      currY = e.clientY - __rect.top + window.pageYOffset;

      ctx.beginPath();
      ctx.fillStyle = "black";
      ctx.fillRect(currX, currY, 2, 2);
      ctx.closePath();
    };

    const onMouseUp = e => {
      socket.send(JSON.stringify({type: 1}));
      drawing = false;
      currX = null;
      currY = null;
    };

    const activateCallbacks = () => {
      clean.onclick = () => socket.send(JSON.stringify({type: 2}));
      leave.onclick = () => {
        roomHeader.textContent = "Canvas";
        leaveRoom();
      };

      socket.onmessage = onSocketMessage;
      canvas.addEventListener("mousemove", onMouseMove);
      canvas.addEventListener("mousedown", onMouseDown);
      canvas.addEventListener("mouseup", onMouseUp);
    };

    const leaveRoom = () => {
      socket.onclose = () => {};
      socket.onerror = () => {};
      socket.close();

      clean.onclick = () => {};
      canvas.removeEventListener("mousemove", onMouseMove);
      canvas.removeEventListener("mousedown", onMouseDown);
      canvas.removeEventListener("mouseup", onMouseUp);

      cleanCanvas();
    };

    const joinRoom = name => {
      roomHeader.textContent = name;
      currX = null;
      currY = null;
      lastPoints = {};

      if (socket)
        leaveRoom();

      socket = new WebSocket(`ws://192.168.1.23:9090/rooms/${name}`);
      socket.onopen = activateCallbacks();
      socket.onclose = () => {
        leaveRoom();
        window.alert("Closed connection to the server, disconnected from the room");
      };
      socket.onerror = () => {
        leaveRoom();
        window.alert("Connection error, disconnected from the room");
      };
    };

    fetch("http://192.168.1.23:9090/rooms", {"mode": "cors"}).then(response => {
      response.json().then(js => {
        for (const room of js) {
          const listRow = roomsList.insertRow(-1);
          listRow.appendChild(document.createTextNode(room));

          let button = document.createElement("input");
          button.type = "button";
          button.value = "join";
          button.class = "join_buttons";
          button.onclick = () => { joinRoom(room); }
          listRow.appendChild(button);
        }
      });
    });
  </script>
</body>
</html>
